/**
 * BaaSCaradhrasAPIDocumentationLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

'use strict';

const _request = require('../Http/Client/RequestClient');
const _configuration = require('../configuration');
const _servers = require('../Servers');
const _apiHelper = require('../APIHelper');
const _baseController = require('./BaseController');

class TollController {
    /**
     * <p>The API works in two step process. First, it requests a recharge cryptogram, this will
     * be saved into the card. At this moment the recharge amount and fee amount is taken from
     * the original account (informed in the request) and transferred to a transitory account.
     * After that, the it must call a second endpoint to confirm or cancel the recharge.</p>
     * <div class="click-to-expand-wrapper is-table-wrapper"><table>
     * <thead>
     * <tr>
     * <th>FIELD NAME</th>
     * <th>FIELD TYPE</th>
     * <th>DESCRIPTION</th>
     * <th>REQUIRED</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td>accountNumber</td>
     * <td>Number</td>
     * <td>Account number to be debited</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>hexCardNumber</td>
     * <td>Alpha</td>
     * <td>This is the card number masked. The mask is BIN + FF + Rest of card number + FF For
     * example, for the card 12345678912345678 the mask should be: 123456FF78912345678FF</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>internalCounterHex</td>
     * <td>Number</td>
     * <td>Amount of transactions with the card in hexadecimal format. This field will be
     * incremented with 1, before cryptogram be generated</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>transactionPartnerNumber</td>
     * <td>Number</td>
     * <td>This field is the id of the transaction. It will be used in all future requests. The
     * maximum character allowed is 15</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>feeTollValue</td>
     * <td>Decimal</td>
     * <td>The fee to be credited into the partner account. This field must be sent as string,
     * for example, “1.00”, because we discard the decimal separator and assume two decimal
     * digits</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>creditTollValue</td>
     * <td>Decimal</td>
     * <td>The value to be credited into the card and wihch the cryptogram is based on. This
     * field must be sent as string, for example, “1.00”, because we discard the decimal
     * separator and assume two decimal digits</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>transactionCounter</td>
     * <td>Number</td>
     * <td>Card's transaction counter</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>cardBalance</td>
     * <td>Number</td>
     * <td>Card's balance. This field must be sent as string, for example, “1.00”, because we
     * discard the decimal separator and assume two decimal digits</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>requestDate</td>
     * <td>Date</td>
     * <td>Request date to be saved into crytogram. Format: yyyy-MM-dd hh:mm:ss</td>
     * <td>Y</td>
     * </tr>
     * </tbody>
     * </table>
     * </div>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     * @param {MTollsRechargesrequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createTollsRecharges(authorization, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/tolls/recharges';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MTollsRecharges');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>1) In case of <code>cancel the transaction</code>, the balance (credit + fee) will be
     * sent back to the original account.</p>
     * <p>2) In case of <code>confirm the transaction</code>, the credit value will be sent to
     * the final account (09), internally called lock funds, because the partner is not supposed
     * to have access to this amount. It’s only for conference. The fee amount will be sent to
     * the partner account (06).</p>
     * <div class="click-to-expand-wrapper is-table-wrapper"><table>
     * <thead>
     * <tr>
     * <th>FIELD NAME</th>
     * <th>FIELD TYPE</th>
     * <th>DESCRIPTION</th>
     * <th>REQUIRED</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td>ChargeIsConfirmed</td>
     * <td>Boolean</td>
     * <td>True to confirm a recharge. False to cancel a recharge</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>transactionCertificate</td>
     * <td>Alpha</td>
     * <td>Transaction certificate, generated by the partner</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>transactionPartnerNumber</td>
     * <td>Number</td>
     * <td>Transaction’s id</td>
     * <td>Y</td>
     * </tr>
     * </tbody>
     * </table>
     * </div>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     * @param {MTollsRechargesrequest1} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateTollsRecharges(authorization, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/tolls/recharges';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MTollsRecharges');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This API generates a cryptogram based on the data received in the request. After that,
     * it debits the account 09 (final account) and credits the account informed in the request.
     * </p>
     * <div class="click-to-expand-wrapper is-table-wrapper"><table>
     * <thead>
     * <tr>
     * <th>FIELD NAME</th>
     * <th>FIELD TYPE</th>
     * <th>DESCRIPTION</th>
     * <th>REQUIRED</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td>accountNumber</td>
     * <td>Number</td>
     * <td>Account number to be debited</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>hexCardNumber</td>
     * <td>Alpha</td>
     * <td>This is the card number masked. The mask is BIN + FF + Rest of card number + FF For
     * example, for the card 12345678912345678 the mask should be: 123456FF78912345678FF</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>internalCounterHex</td>
     * <td>Number</td>
     * <td>Amount of transactions with the card in hexadecimal format. This field will be
     * incremented with 1, before cryptogram be generated</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>transactionPartnerNumber</td>
     * <td>Number</td>
     * <td>This field is the id of the transaction. It will be used in all future requests</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>debitValue</td>
     * <td>Decimal</td>
     * <td>The value to be debited from the account and which the cryptogram is based on. This
     * field must be sent as string, for example, “1.00”, because we discard the decimal
     * separator and assume two decimal digits</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>transactionCounter</td>
     * <td>Number</td>
     * <td>Card's transaction counter</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>cardBalance</td>
     * <td>Number</td>
     * <td>Card's balance. This field must be sent as string, for example, “1.00”, because we
     * discard the decimal separator and assume two decimal digits</td>
     * <td>Y</td>
     * </tr>
     * <tr>
     * <td>requestDate</td>
     * <td>Date</td>
     * <td>Request date to be saved into crytogram. Format: yyyy-MM-dd hh:mm:ss</td>
     * <td>Y</td>
     * </tr>
     * </tbody>
     * </table>
     * </div>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     * @param {MTollsRechargesrequest2} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteTollsRecharges(authorization, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/tolls/recharges';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MTollsRecharges');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>Request</p>
     * <div class="click-to-expand-wrapper is-table-wrapper"><table>
     * <thead>
     * <tr>
     * <th>PATH PARAMETER</th>
     * <th>TYPE</th>
     * <th>DESCRIPTION</th>
     * <th>REQUIRED</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td>numeroTransacaoParceiro</td>
     * <td>Number</td>
     * <td>The id of the transaction, used to locate the data</td>
     * <td>Y</td>
     * </tr>
     * </tbody>
     * </table>
     * </div><p>Response </p>
     * <div class="click-to-expand-wrapper is-table-wrapper"><table>
     * <thead>
     * <tr>
     * <th>FIELD NAME</th>
     * <th>FIELD TYPE</th>
     * <th>DESCRIPTION</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td>Id</td>
     * <td>Number</td>
     * <td>Transaction’s internal id</td>
     * </tr>
     * <tr>
     * <td>destinationAccountNumber</td>
     * <td>Number</td>
     * <td>Destination Account number</td>
     * </tr>
     * <tr>
     * <td>hexCardNumber</td>
     * <td>Alpha</td>
     * <td>Card number in hexadecimal format</td>
     * </tr>
     * <tr>
     * <td>transactionCounter</td>
     * <td>Number</td>
     * <td>Transaction counter</td>
     * </tr>
     * <tr>
     * <td>transactionPartnerNumber</td>
     * <td>Number</td>
     * <td>Partner’s transaction number</td>
     * </tr>
     * <tr>
     * <td>debitValue</td>
     * <td>Decimal</td>
     * <td>Value to be debited from 09 account</td>
     * </tr>
     * <tr>
     * <td>createdOn</td>
     * <td>Datetime</td>
     * <td>Creation’s date</td>
     * </tr>
     * <tr>
     * <td>cryptogram</td>
     * <td>Alpha</td>
     * <td>Cryptogram sent to card</td>
     * </tr>
     * <tr>
     * <td>internalTransactionCode</td>
     * <td>Alpha</td>
     * <td>Transaction code generated on the first request</td>
     * </tr>
     * <tr>
     * <td>internalCounterHex</td>
     * <td>Apha</td>
     * <td>Internal coutner in hexadecimal format</td>
     * </tr>
     * <tr>
     * <td>cardBalance</td>
     * <td>Number</td>
     * <td>Card's balance</td>
     * </tr>
     * </tbody>
     * </table>
     * </div>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getTollsRechargesTransactionPartnerNumber(authorization, contentType, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_5);

        const _pathUrl = '/34943232';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MTollsRecharges34943232');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>Request</p>
     * <div class="click-to-expand-wrapper is-table-wrapper"><table>
     * <thead>
     * <tr>
     * <th>PATH PARAMETER</th>
     * <th>TYPE</th>
     * <th>DESCRIPTION</th>
     * <th>REQUIRED</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td>numeroTransacaoParceiro</td>
     * <td>Number</td>
     * <td>The id of the transaction, used to locate the data</td>
     * <td>Y</td>
     * </tr>
     * </tbody>
     * </table>
     * </div><p>Response </p>
     * <div class="click-to-expand-wrapper is-table-wrapper"><table>
     * <thead>
     * <tr>
     * <th>FIELD NAME</th>
     * <th>FIELD TYPE</th>
     * <th>DESCRIPTION</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td>Id</td>
     * <td>Number</td>
     * <td>Transaction’s internal id</td>
     * </tr>
     * <tr>
     * <td>destinationAccountNumber</td>
     * <td>Number</td>
     * <td>Destination Account number</td>
     * </tr>
     * <tr>
     * <td>hexCardNumber</td>
     * <td>Alpha</td>
     * <td>Card number in hexadecimal format</td>
     * </tr>
     * <tr>
     * <td>transactionCounter</td>
     * <td>Number</td>
     * <td>Transaction counter</td>
     * </tr>
     * <tr>
     * <td>transactionPartnerNumber</td>
     * <td>Number</td>
     * <td>Partner’s transaction number</td>
     * </tr>
     * <tr>
     * <td>debitValue</td>
     * <td>Decimal</td>
     * <td>Value to be debited from 09 account</td>
     * </tr>
     * <tr>
     * <td>createdOn</td>
     * <td>Datetime</td>
     * <td>Creation’s date</td>
     * </tr>
     * <tr>
     * <td>cryptogram</td>
     * <td>Alpha</td>
     * <td>Cryptogram sent to card</td>
     * </tr>
     * <tr>
     * <td>internalTransactionCode</td>
     * <td>Alpha</td>
     * <td>Transaction code generated on the first request</td>
     * </tr>
     * <tr>
     * <td>internalCounterHex</td>
     * <td>Apha</td>
     * <td>Internal coutner in hexadecimal format</td>
     * </tr>
     * <tr>
     * <td>cardBalance</td>
     * <td>Number</td>
     * <td>Card's balance</td>
     * </tr>
     * </tbody>
     * </table>
     * </div>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getTollsDownloadsTransactionPartnerNumber(authorization, contentType, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/tolls/downloads/34943232';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MTollsDownloads34943232');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>Request</p>
     * <div class="click-to-expand-wrapper is-table-wrapper"><table>
     * <thead>
     * <tr>
     * <th>PATH PARAMETER</th>
     * <th>TYPE</th>
     * <th>DESCRIPTION</th>
     * <th>REQUIRED</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td>numeroTransacaoParceiro</td>
     * <td>Number</td>
     * <td>The id of the transaction, used to locate the data</td>
     * <td>Y</td>
     * </tr>
     * </tbody>
     * </table>
     * </div><p>Response </p>
     * <div class="click-to-expand-wrapper is-table-wrapper"><table>
     * <thead>
     * <tr>
     * <th>FIELD NAME</th>
     * <th>FIELD TYPE</th>
     * <th>DESCRIPTION</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td>Id</td>
     * <td>Number</td>
     * <td>Transaction’s internal id</td>
     * </tr>
     * <tr>
     * <td>destinationAccountNumber</td>
     * <td>Number</td>
     * <td>Destination Account number</td>
     * </tr>
     * <tr>
     * <td>hexCardNumber</td>
     * <td>Alpha</td>
     * <td>Card number in hexadecimal format</td>
     * </tr>
     * <tr>
     * <td>transactionCounter</td>
     * <td>Number</td>
     * <td>Transaction counter</td>
     * </tr>
     * <tr>
     * <td>transactionPartnerNumber</td>
     * <td>Number</td>
     * <td>Partner’s transaction number</td>
     * </tr>
     * <tr>
     * <td>debitValue</td>
     * <td>Decimal</td>
     * <td>Value to be debited from 09 account</td>
     * </tr>
     * <tr>
     * <td>createdOn</td>
     * <td>Datetime</td>
     * <td>Creation’s date</td>
     * </tr>
     * <tr>
     * <td>cryptogram</td>
     * <td>Alpha</td>
     * <td>Cryptogram sent to card</td>
     * </tr>
     * <tr>
     * <td>internalTransactionCode</td>
     * <td>Alpha</td>
     * <td>Transaction code generated on the first request</td>
     * </tr>
     * <tr>
     * <td>internalCounterHex</td>
     * <td>Apha</td>
     * <td>Internal coutner in hexadecimal format</td>
     * </tr>
     * <tr>
     * <td>cardBalance</td>
     * <td>Number</td>
     * <td>Card's balance</td>
     * </tr>
     * </tbody>
     * </table>
     * </div>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getTollsRechargesWarmup(authorization, contentType, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_5);

        const _pathUrl = '/warmup';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const parsed = JSON.parse(_response.body);
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
}
module.exports = TollController;
