/**
 * BaaSCaradhrasAPIDocumentationLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

'use strict';

const _request = require('../Http/Client/RequestClient');
const _configuration = require('../configuration');
const _servers = require('../Servers');
const _apiHelper = require('../APIHelper');
const _baseController = require('./BaseController');

class CardController {
    /**
     * <p>This resource allows to be generate a new Card for a determined cardholder that it is
     * linked to the account. For this, itâ€™ll be necessary to inform the id account , the
     * <code>idPessoa</code> of the cardholder and the <code>idTipoPlastico</code>of the card
     * that will be printed, defined on the setup process. This functionality will be used for
     * the card printing in graphic.</p>
     * <ul>
     * <li>This API enables the creation of a physical card. Right after this, it is mandatory to
     * call the <code>POST /cartoes/{idcard}/cadastrar-senha</code> to define the card password .
     * Succefully done this process, the embosser will automatically receive the card printing
     * order to emboss and deliver.</li>
     * <li>To unlock a physical card, the embossing phase needs to be completly done, then you
     * must call the method <code>POST /cartoes/{idCard}/desbloquear</code></li>
     * <li>When using this endpoint, the cardholder will receive no charge of fee (either first
     * issue or reissue)</li>
     * </ul>
     * <blockquote>
     * <p>Check the documentation <a href="https://s3-sa-east-1.amazonaws.com/baas-docs.caradhras.
     * io/Fields_Card.pdf">here</a> for addicional information about identification fields.</p>
     * </blockquote>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     * @param {string} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createContasIdAccountGerarCartaoGrafica(authorization, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/15/gerar-cartao-grafica';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'text/plain; charset=utf-8',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: body,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This resource allows to be created a virtual card for a determined cardholder which one
     * it is linked to an account. For this, it will be necessary to inform the identification
     * code of the account (id). This functionability can be used to creat virtual cards through
     * an App. First of all, it will be necessary to align with the project leader about the use
     * of this endpoint</p>
     *
     * @param {string} dataValidade TODO: type description here
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createContasIdAccountGerarCartaoVirtual(dataValidade,
        authorization,
        contentType,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/13/gerar-cartao-virtual';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            dataValidade,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This endpoint allows to create a temporary card with no embossing.</p>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createContasIdAccountGerarCartaoProvisorio(authorization, contentType, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/13/gerar-cartao-provisorio';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper()
                .mapObject(parsed, 'MContasIdAccountGerarCartaoProvisorio');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>It lists all cards issued by the issuer.</p>
     * <blockquote>
     * <p>Check the FAQs below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360028356611-Status-
     * Cart%C3%A3o">Status - Card</a></li>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360021073272-Existe-algum-
     * par%C3%A2metro-espec%C3%ADfico-para-indicar-que-o-cart%C3%A3o-foi-bloqueado-por-sucessivas-
     * tentativas-com-a-senha-incorreta-Se-sim-qual-seria-">Is there any specific parameter to
     * indicate that card has been blocked by successive attempts with the wrong password? If so,
     * what it would be?</a></li>
     * </ul>
     * </blockquote>
     *
     * @param {string} sort TODO: type description here
     * @param {string} page TODO: type description here
     * @param {string} limit TODO: type description here
     * @param {string} idStatusCartao TODO: type description here
     * @param {string} idEstagioCartao TODO: type description here
     * @param {string} idConta TODO: type description here
     * @param {string} idPessoa TODO: type description here
     * @param {string} idProduto TODO: type description here
     * @param {string} tipoPortador TODO: type description here
     * @param {string} numeroCartao TODO: type description here
     * @param {string} nomeImpresso TODO: type description here
     * @param {string} dataGeracao TODO: type description here
     * @param {string} dataStatusCartao TODO: type description here
     * @param {string} dataEstagioCartao TODO: type description here
     * @param {string} dataValidade TODO: type description here
     * @param {string} dataImpressao TODO: type description here
     * @param {string} arquivoImpressao TODO: type description here
     * @param {string} flagImpressaoOrigemComercial TODO: type description here
     * @param {string} flagProvisorio TODO: type description here
     * @param {string} codigoDesbloqueio TODO: type description here
     * @param {string} sequencialCartao TODO: type description here
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getCartoes(sort,
        page,
        limit,
        idStatusCartao,
        idEstagioCartao,
        idConta,
        idPessoa,
        idProduto,
        tipoPortador,
        numeroCartao,
        nomeImpresso,
        dataGeracao,
        dataStatusCartao,
        dataEstagioCartao,
        dataValidade,
        dataImpressao,
        arquivoImpressao,
        flagImpressaoOrigemComercial,
        flagProvisorio,
        codigoDesbloqueio,
        sequencialCartao,
        authorization,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            sort,
            page,
            limit,
            idStatusCartao,
            idEstagioCartao,
            idConta,
            idPessoa,
            idProduto,
            tipoPortador,
            numeroCartao,
            nomeImpresso,
            dataGeracao,
            dataStatusCartao,
            dataEstagioCartao,
            dataValidade,
            dataImpressao,
            arquivoImpressao,
            flagImpressaoOrigemComercial,
            flagProvisorio,
            codigoDesbloqueio,
            sequencialCartao,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MCartoes');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to get the basic information of a determined card from its ID
     * code(id).</p>
     * <blockquote>
     * <p>Check the FAQs below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360028356611-Status-
     * Cart%C3%A3o">Status - Card</a></li>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360021073272-Existe-algum-
     * par%C3%A2metro-espec%C3%ADfico-para-indicar-que-o-cart%C3%A3o-foi-bloqueado-por-sucessivas-
     * tentativas-com-a-senha-incorreta-Se-sim-qual-seria-">Is there any specific parameter to
     * indicate that card has been blocked by successive attempts with the wrong password? If so,
     * what it would be?</a></li>
     * </ul>
     * </blockquote>
     *
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getCartoesIdCard(authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/1';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MCartoesIdCard');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This operation allows the issuers or their customers to request a new VIA from the card
     * that will be forwarded for printing and posting according to the standard demand already
     * defined by the issuer. For this, it is necessary that the client already has a card and
     * inform its id code so that the client can use this operation. Therefore, this
     * functionality applies only to physical generation cards.</p>
     * <ul>
     * <li>The new card will be created with the same password from the previous card.</li>
     * <li>When using this endpoint, the cardholder will be charged according to the fee defined
     * in the setup (regardless of the cancellation reason)</li>
     * <li>This endpoint <strong>must only</strong> be used with a physical card, otherwise it
     * will generate a physical card from a virtual card.</li>
     * </ul>
     *
     * @param {string} idImagem TODO: type description here
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     * @param {string} idCard TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createCartoesIdCardGerarNovaVia(idImagem,
        authorization,
        contentType,
        idCard,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        let _pathUrl = '/cartoes/{idCard}/gerar-nova-via';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            idCard,
        });

        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            idImagem,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MCartoesIdCardGerarNovaVia');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This operation has as an aim to allow the cardholder determinate the card password.
     * </p>
     *
     * @param {string} authorization TODO: type description here
     * @param {int} senha TODO: type description here
     * @param {string} contentType TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createCartoesIdCardCadastrarSenha(authorization, senha, contentType, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/1122585/cadastrar-senha';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            Authorization: authorization,
            senha,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to be unblocked a determined card that was blocked by trying the
     * incorrect password, from its id code (id).</p>
     *
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createCartoesIdCardDesbloquearSenhaIncorreta(authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/1122584/desbloquear-senha-incorreta';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper()
                .mapObject(parsed, 'MCartoesIdCardDesbloquearSenhaIncorreta');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This operation has as an aim to allow validating that the password informed by the
     * carrier of a determined card are right.</p>
     *
     * @param {string} authorization TODO: type description here
     * @param {int} senha TODO: type description here
     * @param {string} contentType TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getCartoesIdCardValidarSenha(authorization, senha, contentType, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/1122585/validar-senha';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            senha,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MCartoesIdCardValidarSenha');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This operation has as an aim to allow the cardholder of a determined card can definite
     * a password of your own choice.</p>
     * <p>Parameters</p>
     *
     * @param {string} authorization TODO: type description here
     * @param {int} senha <p>Password</p>
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateCartoesIdCardAlterarSenha(authorization, senha, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/7/alterar-senha';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            Authorization: authorization,
            senha,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows the to make the block (temporary) or cancellation (definitive) of a
     * determined card from its ID code. For this, It is necessary to inform what is the motive
     * of this block, that it is to attribute a new StatusCard for the client, among other
     * practices practiced by the issuer.</p>
     * <blockquote>
     * <p>Check the FAQs below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360028356611-Status-
     * Cart%C3%A3o">Status - Card</a></li>
     * </ul>
     * </blockquote>
     * <table>
     * <tr>
     * <th>id_status</th>
     * <th>description</th>
     * </tr>
     * <tr>
     * <td>1</td>
     * <td>Normal</td>
     * </tr>
     * <tr>
     * <td>2</td>
     * <td>Blocked</td>
     * </tr>
     * <tr>
     * <td>3</td>
     * <td>Cancelled</td>
     * </tr>
     * </table>
     *
     * @param {string} idStatus TODO: type description here
     * @param {string} observacao TODO: type description here
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createCartoesIdCardBloquear(idStatus,
        observacao,
        authorization,
        contentType,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/1122584/bloquear';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            id_status: idStatus,
            observacao,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MCartoesIdCardBloquear');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to be unblocked a determined card from its identification code (id).
     * </p>
     *
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createCartoesIdCardDesbloquear(authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/1122584/desbloquear';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MCartoesIdCardDesbloquear');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>It cancels a card.</p>
     * <blockquote>
     * <p>Check the FAQs below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360028356611-Status-
     * Cart%C3%A3o">Status - Card</a></li>
     * </ul>
     * </blockquote>
     * <table>
     * <tr>
     * <th>id_status</th>
     * <th>description</th>
     * </tr>
     * <tr>
     * <td>1</td>
     * <td>Normal</td>
     * </tr>
     * <tr>
     * <td>2</td>
     * <td>Blocked</td>
     * </tr>
     * <tr>
     * <td>3</td>
     * <td>Cancelled</td>
     * </tr>
     * </table>
     *
     * @param {string} idStatus TODO: type description here
     * @param {string} observacao TODO: type description here
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createCartoesIdCardCancelar(idStatus, observacao, authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/32/cancelar';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            id_status: idStatus,
            observacao,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MCartoesIdCardCancelar');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to be listed the possibilities of Status that can be attributed to
     * the Cards</p>
     *
     * @param {string} sort TODO: type description here
     * @param {string} page TODO: type description here
     * @param {string} limit TODO: type description here
     * @param {string} id TODO: type description here
     * @param {string} nome TODO: type description here
     * @param {string} permiteDesbloquear TODO: type description here
     * @param {string} permiteAtribuirComoBloqueio TODO: type description here
     * @param {string} permiteAtribuirComoCancelamento TODO: type description here
     * @param {string} cobrarTarifaAoEmitirNovaVia TODO: type description here
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getStatusCartoes(sort,
        page,
        limit,
        id,
        nome,
        permiteDesbloquear,
        permiteAtribuirComoBloqueio,
        permiteAtribuirComoCancelamento,
        cobrarTarifaAoEmitirNovaVia,
        authorization,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/status-cartoes';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            sort,
            page,
            limit,
            id,
            nome,
            permiteDesbloquear,
            permiteAtribuirComoBloqueio,
            permiteAtribuirComoCancelamento,
            cobrarTarifaAoEmitirNovaVia,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MStatusCartoes');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to retrieve the parameters of a determined Card Status using the
     * identification code (id).</p>
     *
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getStatusCartoesIdStatus(authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/status-cartoes/1';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MStatusCatoesIdCard');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to be updated the card stage for another informed resquest.</p>
     * <blockquote>
     * <p>Check the FAQs below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360022453512-Como-sei-o-
     * est%C3%A1gio-em-que-um-cart%C3%A3o-est%C3%A1-Em-qual-est%C3%A1gio-posso-efetuar-o-
     * cancelamento-do-cart%C3%A3o-">How do I know at which stage the card is? In which stage can
     * I cancel the card?</a></li>
     * </ul>
     * </blockquote>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     * @param {string} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createCartoesIdCardAlterarEstagio(authorization, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/1234/alterar-estagio';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'text/plain; charset=utf-8',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: body,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MCartoesIdAlterarEstagio');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This resource allows the validation of the cvv of the card.</p>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     * @param {MCartoesIdCardValidarCvvRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createCartoesIdCardValidarCvv(authorization, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/1122584/validar-cvv';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This endpoint only applies for no-name cards Business Model.</p>
     * <p>This operation has the purpose of allowing Issuers to manage a certain amount of
     * Prepaid Cards, in a non-nominal manner, which may be marketed and subsequently linked to a
     * customer that purchases it. To do this, in addition to defining how many cards should be
     * generated, it will be possible to define the Business Source, Product, Card Type, Image
     * and Address for delivery of the Cards present in the generated batch. By default, all
     * cards will be associated with a fictitious idPessoa and will receive a unique idConta for
     * each of them. Once this is done, the Cards generated by this operation will follow the
     * same graphic printing processes previously defined between the Issuer and the Driver</p>
     * <blockquote>
     * <p>Check the documentation <a href="https://s3-sa-east-1.amazonaws.com/baas-docs.caradhras.
     * io/Fields_Card.pdf">here</a> for addicional information about identification fields.</p>
     * </blockquote>
     * <blockquote>
     * <p>Check the FAQs below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360020758991">How to request -
     * NoName Card</a></li>
     * </ul>
     * </blockquote>
     *
     * @param {string} idOrigemComercial TODO: type description here
     * @param {string} idProduto TODO: type description here
     * @param {string} idTipoCartao TODO: type description here
     * @param {string} idImagem TODO: type description here
     * @param {string} idEndereco TODO: type description here
     * @param {string} quantidadeCartoes TODO: type description here
     * @param {string} identificadorExterno TODO: type description here
     * @param {string} contentType TODO: type description here
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createCartoesLotesCartoesPrePagos(idOrigemComercial,
        idProduto,
        idTipoCartao,
        idImagem,
        idEndereco,
        quantidadeCartoes,
        identificadorExterno,
        contentType,
        authorization,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/lotes-cartoes-pre-pagos';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            idOrigemComercial,
            idProduto,
            idTipoCartao,
            idImagem,
            idEndereco,
            quantidadeCartoes,
            identificadorExterno,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'Content-Type': contentType,
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper()
                .mapObject(parsed, 'MCartoesLotesCartoesPrePagos');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to be listed the exitent pre-paid cards in the base of the issuer.
     * </p>
     *
     * @param {string} sort TODO: type description here
     * @param {string} page TODO: type description here
     * @param {string} limit TODO: type description here
     * @param {string} idOrigemComercial TODO: type description here
     * @param {string} idProduto TODO: type description here
     * @param {string} idTipoCartao TODO: type description here
     * @param {string} idImagem TODO: type description here
     * @param {string} idEndereco TODO: type description here
     * @param {string} quantidadeCartoes TODO: type description here
     * @param {string} dataCadastro TODO: type description here
     * @param {string} usuarioCadastro TODO: type description here
     * @param {string} statusProcessamento TODO: type description here
     * @param {string} identificadorExterno TODO: type description here
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getCartoesLotesCartoesPrePagos(sort,
        page,
        limit,
        idOrigemComercial,
        idProduto,
        idTipoCartao,
        idImagem,
        idEndereco,
        quantidadeCartoes,
        dataCadastro,
        usuarioCadastro,
        statusProcessamento,
        identificadorExterno,
        authorization,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/lotes-cartoes-pre-pagos';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            sort,
            page,
            limit,
            idOrigemComercial,
            idProduto,
            idTipoCartao,
            idImagem,
            idEndereco,
            quantidadeCartoes,
            dataCadastro,
            usuarioCadastro,
            statusProcessamento,
            identificadorExterno,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows retrieving the existent pre-paid cards in the base of the issuer
     * through the ID of the Lot.</p>
     *
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getCartoesLotesCartoesPrePagosId(authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/lotes-cartoes-pre-pagos/2';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper()
                .mapObject(parsed, 'MCartoesLotesCartoesPrePagosId');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This me thod allows to retrieve the limits configurated for the cardholder of a
     * determined card, either it is the holder of the account or an additional, starting from
     * the identification code of the Card (id).</p>
     *
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getCartoesIdCardLimitesDisponibilidades(authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/1/limites-disponibilidades';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper()
                .mapObject(parsed, 'MCartoesIdCardLimitesDisponibilidades');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This endpoint only applies for no-name cards Business Model.</p>
     * <p>It assigns a person as a card owner.</p>
     *
     * @param {string} idPessoa TODO: type description here
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateCartoesIdCardAtribuirTitular(idPessoa, authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/7/atribuir-titular';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            id_pessoa: idPessoa,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper()
                .mapObject(parsed, 'MCartoesIdCardAtribuirTitular');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method retrieves some relevant information about the card that are not displayed
     * at other endpoints.</p>
     *
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getCartoesIdConsultarDadosReais(authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/7/consultar-dados-reais';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper()
                .mapObject(parsed, 'MApiCartoesIdConsultarDadosReais');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This resource allows to search the dates of a Card printed.</p>
     *
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getCartoesIdConsultarDadosImpressao(authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/cartoes/7/consultar-dados-impressao';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper()
                .mapObject(parsed, 'MCartoesIdConsultarDadosImpressao');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
}
module.exports = CardController;
