/**
 * BaaSCaradhrasAPIDocumentationLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

'use strict';

const _request = require('../Http/Client/RequestClient');
const _configuration = require('../configuration');
const _servers = require('../Servers');
const _apiHelper = require('../APIHelper');
const _baseController = require('./BaseController');

class AccountController {
    /**
     * <p>Creates an account in the database of the Issuer.</p>
     * <blockquote>
     * <p>Check the documentation <a href="https://s3-sa-east-1.amazonaws.com/baas-docs.caradhras.
     * io/Fields_Register_Client.pdf">here</a> for addicional information about
     * <code>identification fields</code>.</p>
     * </blockquote>
     * <blockquote>
     * <p>Check the FAQs below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360027496192">Why all accounts
     * should have membership card?</a></li>
     * </ul>
     * </blockquote>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     * @param {string} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createContas(authorization, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'text/plain; charset=utf-8',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: body,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MContasId');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This resource allows to list existent accounts in the database of the Issuer.</p>
     * <blockquote>
     * <p>Check the FAQs below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360029847012-Para-que-servem-
     * as-contas-de-1-a-10-">What the accounts from 1 to 10 are for?</a></li>
     * </ul>
     * </blockquote>
     * <p>Filters allowed to this method: </p>
     * <ul>
     * <li>page</li>
     * <li>Limits (Limit of elements per request: Default = 50, Max = 50)</li>
     * <li>idPessoa (Identification Code of the Personal holder of the Account (id))</li>
     * <li>idProduto (Identification Code of the product which the account takes part (id).
     * )</li>
     * <li>idStatusConta (Identification Code of the Account Status)</li>
     * <li>dataCadastro (List the date that the card was created)</li>
     * </ul>
     *
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getContas(authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MContas');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to retrieve dates of a determined account using the identification
     * code (id).</p>
     * <blockquote>
     * <p>Check the FAQs below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360029847012-Para-que-servem-
     * as-contas-de-1-a-10-">What the accounts from 1 to 10 are for?</a></li>
     * </ul>
     * </blockquote>
     *
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getContasIdAccount(authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/10057584';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MContasId1');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows a person in the base to be a complement to the informed account.
     * </p>
     * <blockquote>
     * <p>Check the documentation <a href="https://s3-sa-east-1.amazonaws.com/baas-docs.caradhras.
     * io/Fields_Register_Client.pdf">here</a> for addicional information about
     * <code>identification fields</code>.</p>
     * </blockquote>
     *
     * @param {string} contentType TODO: type description here
     * @param {string} authorization TODO: type description here
     * @param {string} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createContasIdAccountsAdicionais(contentType, authorization, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/123/adicionais';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'text/plain; charset=utf-8',
            'Content-Type': contentType,
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: body,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MContasIdAccountsAdicionais');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to retrieve the additional persons to a specific account.</p>
     *
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getContasIdAccountAdicionais(authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/10/adicionais';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MContasIdAccountAdicionais');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to be updated an additional carrier of a determined account.</p>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     * @param {MContasIdAdicionaisIdPessoaRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateContasIdAdicionaisIdPessoa(authorization, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/10/adicionais/1234';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MContasIdAdicionaisIdPessoa');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to be updated an additional carrier of a determined account.</p>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     * @param {MContasIdPessoasIdPessoaPortadoresRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateContasIdPessoasIdPessoaPortadores(authorization, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_4);

        const _pathUrl = '/portadores';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PATCH',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const parsed = JSON.parse(_response.body);
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows tobe inactived an additional carrier of a determined account.</p>
     *
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createContasIdAdicionaisIdPessoaInativar(authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/10/adicionais/1234/inativar';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const parsed = JSON.parse(_response.body);
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to block a determined account using de id account code (id).</p>
     * <blockquote>
     * <p>Check the FAQ below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360028356611-Status-
     * Cart%C3%A3o">Status - Card</a></li>
     * </ul>
     * </blockquote>
     * <p> "id_status" : </p>
     * <table>
     * <tr>
     * <th>id_status</th>
     * <th>description</th>
     * </tr>
     * <tr>
     * <td>0</td>
     * <td>Normal</td>
     * </tr>
     * <tr>
     * <td>1</td>
     * <td>Blocked</td>
     * </tr>
     * <tr>
     * <td>2</td>
     * <td>Canceled</td>
     * </tr>
     * </table>
     *
     * @param {string} idStatus TODO: type description here
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createContasIdAccountBloquear(idStatus, authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/10057672/bloquear';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            id_status: idStatus,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MContasIdBloquear');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to cancel a specific account using de id account code (id).</p>
     * <blockquote>
     * <p>Check the FAQ below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360028356611-Status-
     * Cart%C3%A3o">Status - Card</a></li>
     * </ul>
     * </blockquote>
     * <p> Possible "id_status" return : </p>
     * 
     * <p></p>
     * 
     * <table>
     * <tr>
     * <th>id_status</th>
     * <th>description</th>
     * </tr>
     * <tr>
     * <td>0</td>
     * <td>Normal</td>
     * </tr>
     * <tr>
     * <td>1</td>
     * <td>Blocked</td>
     * </tr>
     * <tr>
     * <td>2</td>
     * <td>Canceled</td>
     * </tr>
     * </table>
     *
     * @param {string} idStatus TODO: type description here
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createContasIdAccountCancelar(idStatus, authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/10057672/cancelar';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            id_status: idStatus,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MContasIdBloquear');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This resource allows to reactivate the accounts. For this, It’s necessary to inform the
     * idcode of the account (id).</p>
     *
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createContasIdAccountReativar(authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/10057584/reativar';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows to change the product of a specific account.</p>
     * <blockquote>
     * <p>Check the FAQs below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360031336671">How to change
     * the idCommercialOrigin?</a></li>
     * </ul>
     * </blockquote>
     *
     * @param {string} authorization TODO: type description here
     * @param {string} contentType TODO: type description here
     * @param {MContasIdAccountAlterarProdutoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createContasIdAccountAlterarProduto(authorization, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/10057672/alterar-produto';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            Authorization: authorization,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This operation has as an aim to allow a listing, in a timeline mode, of the events
     * linked to a determined account. Transactions, invoice closing, payments, create cards and
     * update the limit are exemples of the events contemplated for this funcionality. In this
     * method, the operations are ordered in descending form.</p>
     * <blockquote>
     * <p>Check the FAQ below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360030823631">How to identify
     * a paid Recharge Bank Slip?</a></li>
     * </ul>
     * </blockquote>
     *
     * @param {string} sort TODO: type description here
     * @param {string} page TODO: type description here
     * @param {string} limit TODO: type description here
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getContasIdAccountTimeline(sort, page, limit, authorization, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/10057584/timeline';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            sort,
            page,
            limit,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MContasIdTimeline');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows all unprocessed and processed transactions in the Account to be
     * listed.</p>
     * <blockquote>
     * <p>Check the FAQs below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360030829612">Where can I find
     * more information on the withdrawal?</a></li>
     * </ul>
     * </blockquote>
     *
     * @param {string} sort TODO: type description here
     * @param {string} page TODO: type description here
     * @param {string} limit TODO: type description here
     * @param {string} dataVencimento TODO: type description here
     * @param {string} dataInicio TODO: type description here
     * @param {string} dataFim TODO: type description here
     * @param {string} idTipoTransacao TODO: type description here
     * @param {string} flagCredito TODO: type description here
     * @param {string} flagFaturado TODO: type description here
     * @param {string} flagProcessada TODO: type description here
     * @param {string} plano TODO: type description here
     * @param {string} codigoMCC TODO: type description here
     * @param {string} grupoMCC TODO: type description here
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getContasIdAccountTransacoes(sort,
        page,
        limit,
        dataVencimento,
        dataInicio,
        dataFim,
        idTipoTransacao,
        flagCredito,
        flagFaturado,
        flagProcessada,
        plano,
        codigoMCC,
        grupoMCC,
        authorization,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/contas/10057584/transacoes';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            sort,
            page,
            limit,
            dataVencimento,
            dataInicio,
            dataFim,
            idTipoTransacao,
            flagCredito,
            flagFaturado,
            flagProcessada,
            plano,
            codigoMCC,
            grupoMCC,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'MContasIdTransacoes');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows all unprocessed and processed transactions in the Account to be
     * listed.</p>
     * <p>This method may merge the processed transactions into one. Therefore, the total
     * quantity of elements may differ from the quantity shown.</p>
     * <blockquote>
     * <p>Check the FAQs below:</p>
     * <ul>
     * <li><a href="https://baas-cdt.zendesk.com/hc/pt-br/articles/360030829612">Onde consigo
     * mais informações sobre o saque?</a></li>
     * </ul>
     * </blockquote>
     *
     * @param {string} sort TODO: type description here
     * @param {string} page TODO: type description here
     * @param {string} limit TODO: type description here
     * @param {string} dueDate TODO: type description here
     * @param {string} startDate TODO: type description here
     * @param {string} endDate TODO: type description here
     * @param {string} creditFlag TODO: type description here
     * @param {string} mccCode TODO: type description here
     * @param {string} groupMcc TODO: type description here
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getAccountsIdAccountTransactions(sort,
        page,
        limit,
        dueDate,
        startDate,
        endDate,
        creditFlag,
        mccCode,
        groupMcc,
        authorization,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/accounts/4/transactions';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            sort,
            page,
            limit,
            dueDate,
            startDate,
            endDate,
            creditFlag,
            mccCode,
            groupMcc,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * <p>This method allows all denied account transactions to be listed.</p>
     * <p>It shows only the transactions denied by our authorizer, but it does not shows
     * transactions denied by the acquirer or by the card scheme.</p>
     *
     * @param {string} sort TODO: type description here
     * @param {string} page TODO: type description here
     * @param {string} limit TODO: type description here
     * @param {string} idCard TODO: type description here
     * @param {string} authorization TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getAccountsIdAccountTransactionsDenied(sort,
        page,
        limit,
        idCard,
        authorization,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri(_servers.SERVER_3);

        const _pathUrl = '/accounts/10/transactions/denied';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            sort,
            page,
            limit,
            idCard,
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            Authorization: authorization,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, _response.body, _context);
                    _fulfill(_response.body);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
}
module.exports = AccountController;
